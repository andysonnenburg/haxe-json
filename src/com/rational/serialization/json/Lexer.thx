package com.rational.serialization.json;

import com.rational.utils.CharCodes;
import com.rational.utils.Tools;
import com.rational.utils.Stream;

using StringTools;

private typedef CC = CharCodes;
private typedef S = LexerStates;
private typedef T = Tools;

class Lexer {
	private var stream:Stream<Int>;
	
	public function new(stream:Stream<Null<Int>>) {
		this.stream = stream;
	}
	
	private inline function nextCode():Int {
		return stream.pop();
	}
	
	private inline function unexpected():Void {
		throw new LexerError("Unexpected \"" + String.fromCharCode(stream.peek()) + "\"");
	}
	
	private inline function internalError():Void {
		throw new LexerError("Internal error");
	}
	
	public function next():Token {
		var state:Int = S.START;
		var buf:StringBuf = null;
		var hexBuf:StringBuf = null;
		var token:Token;
		skipWhitespace();
		while (true) {
			switch (state) {
				case S.START:
					switch (nextCode()) {
						case CC.LEFT_BRACE: return Token.LEFT_BRACE;
						case CC.RIGHT_BRACE: return Token.RIGHT_BRACE;
						case CC.LEFT_BRACKET: return Token.LEFT_BRACKET;
						case CC.RIGHT_BRACKET: return Token.RIGHT_BRACKET;
						case CC.COMMA: return Token.COMMA;
						case CC.COLON: return Token.COLON;
						case CC.t: state = S.t;
						case CC.f: state = S.f;
						case CC.n: state = S.n;
						case CC.QUOTATION_MARK:
							buf = new StringBuf();
							state = S.QUOTATION_MARK;
						case CC.MINUS:
							buf = new StringBuf();
							buf.addChar(CC.MINUS);
							state = S.MINUS;
						case CC.ZERO:
							buf = new StringBuf();
							buf.addChar(CC.ZERO);
							state = S.LEADING_ZERO;
						$$cases(
							CC.ONE,
							CC.TWO,
							CC.THREE,
							CC.FOUR,
							CC.FIVE,
							CC.SIX,
							CC.SEVEN,
							CC.EIGHT,
							CC.NINE,
								buf = new StringBuf();
								buf.addChar(::matched::);
								state = S.INTEGRAL;
						)
						default: unexpected();
					}
				case S.t:
					switch (nextCode()) {
						case CC.r: state = S.tr;
						default: unexpected();
					}
				case S.tr:
					switch (nextCode()) {
						case CC.u: state = S.tru;
						default: unexpected();
					}
				case S.tru:
					switch (nextCode()) {
						case CC.e: return Token.TRUE;
						default: unexpected();
					}
				case S.f:
					switch (nextCode()) {
						case CC.a: state = S.fa;
						default: unexpected();
					}
				case S.fa:
					switch (nextCode()) {
						case CC.l: state = S.fal;
						default: unexpected();
					}
				case S.fal:
					switch (nextCode()) {
						case CC.s: state = S.fals;
						default: unexpected();
					}
				case S.fals:
					switch (nextCode()) {
						case CC.e: return Token.FALSE;
						default: unexpected();
					}
				case S.n:
					switch (nextCode()) {
						case CC.u: state = S.nu;
						default: unexpected();
					}
				case S.nu:
					switch (nextCode()) {
						case CC.l: state = S.nul;
						default: unexpected();
					}
				case S.nul:
					switch (nextCode()) {
						case CC.l: return Token.NULL;
						default: unexpected();
					}
				case S.QUOTATION_MARK:
					var code = stream.pop();
					switch (code) {
						case CC.REVERSE_SOLIDUS: state = S.REVERSE_SOLIDUS;
						case CC.QUOTATION_MARK:	state = S.STRING;
						default: buf.addChar(code);
					}
				case S.REVERSE_SOLIDUS:
					switch (nextCode()) {
						case CC.QUOTATION_MARK:
							buf.addChar(CC.QUOTATION_MARK);
							state = S.QUOTATION_MARK;
						case CC.REVERSE_SOLIDUS:
							buf.addChar(CC.REVERSE_SOLIDUS);
							state = S.QUOTATION_MARK;
						case CC.SOLIDUS:
							buf.addChar(CC.SOLIDUS);
							state = S.QUOTATION_MARK;
						case CC.b:
							buf.addChar(CC.BACKSPACE);
							state = S.QUOTATION_MARK;
						case CC.f:
							buf.addChar(CC.FORMFEED);
							state = S.QUOTATION_MARK;
						case CC.n:
							buf.addChar(CC.NEWLINE);
							state = S.QUOTATION_MARK;
						case CC.r:
							buf.addChar(CC.CARRIAGE_RETURN);
							state = S.QUOTATION_MARK;
						case CC.t:
							buf.addChar(CC.HORIZONTAL_TAB);
							state = S.QUOTATION_MARK;
						case CC.u:
							hexBuf = new StringBuf();
							state = S.UNICODE_ESCAPE;
						default: unexpected();
					}
				case S.UNICODE_ESCAPE:
					hexDigit(hexBuf);
					state = S.HEX_DIGIT1;
				case S.HEX_DIGIT1:
					hexDigit(hexBuf);
					state = S.HEX_DIGIT2;
				case S.HEX_DIGIT2:
					hexDigit(hexBuf);
					state = S.HEX_DIGIT3;
				case S.HEX_DIGIT3:
					hexDigit(hexBuf);
					buf.addChar(T.parseHex(hexBuf.toString()));
					state = S.QUOTATION_MARK;
				case S.MINUS:
					switch(nextCode()) {
						case CC.ZERO:
							buf.addChar(CC.ZERO);
							state = S.LEADING_ZERO;
						$$cases(
							CC.ONE,
							CC.TWO,
							CC.THREE,
							CC.FOUR,
							CC.FIVE,
							CC.SIX,
							CC.SEVEN,
							CC.EIGHT,
							CC.NINE,
								buf.addChar(::matched::);
								state = S.INTEGRAL;
						)
					}
				case S.LEADING_ZERO: state = fractionalOrExponential(buf);
				case S.INTEGRAL:
					if (!digit(buf)) {
						state = fractionalOrExponential(buf);
					}
				case S.LEADING_FRACTIONAL:
					if (!digit(buf)) {
						unexpected();
					}
					state = S.FRACTIONAL;
				case S.FRACTIONAL:
					if (!digit(buf)) {
						state = exponential(buf);							
					}
				case S.LEADING_EXPONENTIAL:
					if (!digit(buf)) {
						unexpected();
					}
					state = S.EXPONENTIAL;
				case S.EXPONENTIAL:
					if (!digit(buf)) {
						state = S.NUMBER;
					}
				case S.STRING: return Token.STRING(buf.toString());
				case S.NUMBER: return Token.NUMBER(Std.parseFloat(buf.toString()));
				default: internalError();
			}
		}
		internalError();
	}
	
	private inline function hexDigit(buf:StringBuf):Void {
		switch (stream.peek()) {
			$$cases(
				CC.ZERO,
				CC.ONE,
				CC.TWO,
				CC.THREE,
				CC.FOUR,
				CC.FIVE,
				CC.SIX,
				CC.SEVEN,
				CC.EIGHT,
				CC.NINE,
				CC.A, CC.a,
				CC.B, CC.b,
				CC.C, CC.c,
				CC.D, CC.d,
				CC.E, CC.e,
				CC.F, CC.f,
					stream.skip();
					buf.addChar(::matched::);
			)
			default: unexpected();
		}
	}
	
	private function fractionalOrExponential(buf:StringBuf):Int {
		var code:Null<Int> = stream.peek();
		if (code == null) {
			return S.NUMBER;
		}
		switch (code) {
			case CC.PERIOD:
				stream.skip();
				buf.addChar(CC.PERIOD);
				return S.LEADING_FRACTIONAL;
			$$cases(
				CC.e,
				CC.E,
					stream.skip();
					buf.addChar(::matched::);
					return S.LEADING_EXPONENTIAL;
			)
			default: return S.NUMBER;
		}
		internalError();
	}
	
	private function exponential(buf:StringBuf):Int {
		var code:Null<Int> = stream.peek();
		if (code == null) {
			return S.NUMBER;
		}
		switch (code) {
			$$cases(
				CC.e,
				CC.E,
					stream.skip();
					buf.addChar(::matched::);
					return S.LEADING_EXPONENTIAL;
			)
			default: return S.NUMBER;
		}
	}
	
	private function digit(buf:StringBuf):Bool {
		switch (stream.peek()) {
			$$cases(
				CC.ZERO,
				CC.ONE,
				CC.TWO,
				CC.THREE,
				CC.FOUR,
				CC.FIVE,
				CC.SIX,
				CC.SEVEN,
				CC.EIGHT,
				CC.NINE,
					stream.skip();
					buf.addChar(::matched::);
					return true;
			)
			default: return false;
		}
	}
	
	private inline function skipWhitespace():Void {
		while (true) {
			switch (stream.peek()) {
				$$cases(
					0x0009,
					0x000A,
					0x000B,
					0x000C,
					0x000D,
					0x0020,
					0x0085,
					0x00A0,
					0x1680,
					0x180E,
					0x2000,
					0x2001,
					0x2002,
					0x2003,
					0x2004,
					0x2005,
					0x2006,
					0x2007,
					0x2008,
					0x2009,
					0x200A,
					0x2028,
					0x2029,
					0x202F,
					0x205F,
					0x3000,
						stream.skip();
				)
				default:
					break;
			}
		}
	}
}
